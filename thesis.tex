% !TEX TS-program = xelatex
% !TEX encoding = UTF-8 Unicode
% !TEX spellcheck = ru-RU
% !BIB program = biber

\documentclass[a4paper,14pt]{extarticle} % ext for 14 font

\usepackage{etoolbox}
\newbool{comicsans}
\boolfalse{comicsans}

\input{preamble}

\begin{document}
	\include{title_page}
	\centertitle{Задание на ВКР}
	\centertitle{График выполнения ВКР}
	\centertitle{Аннотация на русском языке}
	\centertitle{Аннотация на английском языке}
	
	\newpage
	\tableofcontents
	\newpage
	
	\input{intro}
	
	\newpage
	\section{Актуальность работы}
	
	Смартфон --- неотъемлемая часть жизни современного человека. Человек может использовать телефон до 200 раз каждый день~\parencite{falaki2010diversity}. Тем не менее, смартфоны всё ещё не достигли потолка своего развития и многие аспекты нуждаются в улучшении. Одним из таких является энергопотребление устройства.
	
	Проблема заключается в том, что с развитием вычислителей и экранов, которые потребляют всё больше энергии, аккумуляторы должны развиваться с сопоставимой скоростью, чтобы покрыть растущие затраты и оставить время работы устройства от батареи хотя бы на том же уровне. Но развитие аккумуляторов устройств происходит не так быстро~\parencite{pentikousis2010search}, что заставляет задуматься о более эффективном расходовании уже имеющейся энергии.
	
	Раньше мобильные телефоны могли работать более недели от одного заряда аккумулятора, но с их развитием такая возможность была потеряна. Как видно на диаграмме (рис. 1), процесс увеличения числа возможностей портативных устройств сопряжён с уменьшением времени работы прибора. Если в 1996 году портативное устройство было способно работать 8-10 недель до разрядки аккумулятора, то уже в 2004 году наличие камеры, диктофона, Bluetooth, цветного дисплея и другой функциональности сократили время работы до недели и меньше~\parencite{василенко2005методы}.
	
	Имеют место большое количество факторов, которые влияют на потребление энергии. Это взаимодействие с сетью, множество сенсоров и датчиков, камера, экран и другие. Существуют академические работы, показывающие возможность оптимизировать потребление многих факторов, например, взаимодействие с интернетом~\parencite{tuysuz2019real} или более оптимальное использование оперативной памяти может продлить срок работы устройства от аккумулятора~\parencite{li2014investigation}. Но также исследования показывают, что в большинстве сценариев использования смартфона энергозатраты на экран составляют больше половины всех энергозатрат~\parencite{bai2013android}. Становится очевидным, что именно потребление экрана нуждается в оптимизации в первую очередь.
	
	Существует множество подходов к уменьшению потребления экрана, которые основываются на самых разных идеях. Некоторые считают, что изменение цветовой схемы интерфейса на AMOLED экранах поможет снизить затраты~\parencite{wan2015detecting}, другие понижают кадровую частоту и частоту обновления экрана~\parencite{lee2018improving, huang2014intelligent}. 
	
	Новизна моего исследования базируется на предположении, что взаимозаменяемые виджеты со схожей функциональностью потребляют разное количество энергии, что позволяет заменить более затратные виджеты на аналогичные и уменьшить энергопотребление.
	
	Практическое применение моей работы заключается в помощи разработчикам Android-приложений в выборе наиболее эффективных элементов графического интерфейса и улучшение общего качества приложения. Ожидается, что этого удастся достигнуть путём непрерывного сканирования иерархии виджетов с целью поиска тех, которые могут быть заменены на более оптимальные, и сообщения об этом разработчику мобильного приложения.
	
	\newpage
	\section{Обзор литературы} % Анализ существующих технических решений объекта разработки
	
	В этой главе я рассмотрю работы, затрагивающие проблему энергопотребления мобильных устройств, и предлагающие пути её решения. Это необходимо для понимания проделанной  исследователями работы, а также изучения методик и инструментов, используемых для проведения измерений.
	
	\subsection{Проблемы пользователей и разработчиков мобильных приложений}
	
	Я считаю необходимым иметь представление о реальных проблемах мобильных приложений как по мнению пользователей, так и понимать проблемы, стоящие перед разработчиками приложений. Это поможет правильно расставить приоритеты исследования и разработать наиболее удобное и полезное решение по контролю энергопотребления.
	
	Одна из проблем, освещённая в статье Мана, Гао и др., связана с пользовательским восприятием приложений~\parencite{man2016experience}. Авторами был создан новый фреймворк под названием CrossMiner для автоматического анализа проблем приложений из отзывов пользователей с помощью метода, основанного на ключевых словах. Основываясь на пяти миллионах отзывов пользователей, платформа автоматически фиксирует распределение семи проблем приложения, а именно: “батарея”, “сбой”, “память”, “сеть”, “конфиденциальность”, “спам” и “пользовательский интерфейс”. По итогу было выявлено, что проблемы, связанные со “сбоем” и “сетью”, больше беспокоят пользователей, чем другие проблемы на трех рассматриваемых платформах (Google Play, App Store и Windows Store).
	
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{install_reasons}
		\caption{Причины установки приложений пользователями}
		\label{fig:install_reasons}
	\end{figure}
	
	В другой работе задача состояла в том, чтобы определить причины, по которым пользователи выбирают и устанавливают мобильные приложения из магазинов приложений~\parencite{ickin2017users}. А также причины, по которым пользователи удаляют приложения. Было проведено анкетирование с участием 121 пользователя из 26 различных стран. Как видно на диаграмме \ris{\ref{fig:install_reasons}}, самыми частыми причинами установки приложения являются его описание, оценки пользователей и скриншоты приложения. Согласно другим данным \ris{\ref{fig:delete_reasons}} в топе причин удаления --- бесполезность, сбои, высокое использование оперативной памяти.
	
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{delete_reasons}
		\caption{Причины удаления приложений пользователями}
		\label{fig:delete_reasons}
	\end{figure}
	
	С точки зрения инженеров~\parencite{wasserman2010software} наиболее остро стоят следующий вопросы: 
	\begin{itemize}
		\item Улучшение пользовательского опыта; 
		\item Нефункциональные требования (производительность, энергоэффективность, надёжность, качество, безопасность);
		\item Процессы, инструменты и архитектура; 
		\item Переносимость на другие платформы. 
	\end{itemize}

	Эти пункты являются лишь подмножеством возможных тем исследований в области разработки программного обеспечения для мобильных приложений, но служат для обозначения широты исследовательских потребностей и возможностей в этой формирующейся области.
	
	\subsection{Измерение энергопотребления устройств}

	Как мы выяснили ранее, понимание энергопотребления компонентов смартфона является одной из ключевых областей интереса для конечных пользователей, а также разработчиков приложений и системного программного обеспечения. Существующая литература предлагает множество решений для эффективного измерения энергопотребления, что помогает определить влияние различных подходов к оптимизации.
	
	В другой работе был предложен программный инструмент, использующий технологии параллельного программирования OpenMP и Cilk Plus~\parencite{калачев2013разработка}. В серии экспериментов они оказались более энергоэффективными, чем последовательные реализации. Архитектура системы обеспечивает ее расширяемость, позволяя добавлять новые источники данных, метрики и способы визуализации, что значительно выделяет разработку среди остальных.
	
	В зарубежных исследованиях также можно отметить тенденцию предложения использования конкретного инструментария, которые предлагают сами авторы работы. Так, в департаменте компьютерных наук университета Ёнсе в Южной Корее, был разработан AppScope --- приложение для автоматического измерения энергопотребления приложений Android с помощью мониторинга активности ядра~\parencite{yoon2012appscope}. Оно отслеживает системные вызовы, а также анализирует данные механизма IPC операционной системы . 
	
	Проектная группа из университета Джорджа Мейсона и Национального института стандартов и технологий США представила систему, которая эффективно учитывает энергопотребление всех основных аппаратных подсистем телефона: процессора, дисплея, графики, GPS, аудио, микрофона и Wi-Fi~\parencite{murmuria2012mobile}. Для этого они использовали доли времени для каждой подсистемы, сообщаемые модулем управления питанием операционной системы. Предложенное решение позволяет работать в режиме реального времени без значительного влияния на энергопотребление подконтрольного устройства, что может помочь разработчикам принять более оптимальные решения для повышения энергоэффективности.

	\subsection{Оптимизации на уровне исходного кода}

	Одним из инновационных подходов к снижению потребления энергии устройством является оптимизация затрат процессорного времени, которое требуется для выполнения вычислительных задач. В данной главе будут рассмотрены пути оптимизации исходного кода программы с целью сокращения времени нагруженной работы процессора и скорейшего его перехода в энергосберегающий режим.
	
	Исследование показало, что JavaScript экономит больше энергии и работает медленнее, чем другие подходы, и что гибридизация приложений может быть решением для оптимизации приложений как с точки зрения производительности, так и энергопотребления~\parencite{oliveira2017study}. Среди двух вариантов гибридизации использование NDK является наиболее безопасным вариантом для повышения производительности, но использование веб-подхода может дать лучший результат при небольшом количестве кросс-языковых вызовов.
	
	В статье Сео, Малека и Медвидовика представлена структура для оценки энергопотребления программных систем на основе Java~\parencite{seo2007energy}. Её инфраструктура явно использует компонентную перспективу, что делает ее подходящей для большого класса современных распределенных, встроенных и распространяющихся приложений. В большом количестве сценариев распределенных приложений платформа показала очень хорошую точность в целом, давая результаты, которые были в пределах 5\% от фактического потребления энергии, понесенного при выполнении программного обеспечения. 
	
	Ещё одно исследование относительно Java сфокусировано вокруг сжатия --- одного из популярных механизмов для снижения требований систем к памяти~\parencite{гуанджиу2004экономия}. В статье рассматривается влияние сжатия на использование системных ресурсов встроенной виртуальной машиной Java (JVM), а также алгоритмы сжатия. Опыты показали, что экономия энергии составляет в среднем 21\%. В двух приложениях, где декомпрессия играет большую роль, результаты получаются хуже, чем в случае оригинала.
	
	\subsection{Общие  методы оптимизации потребления ресурсов для портативных устройств}
	
	Многие проблемы энергопотребления приходилось решать ранее для оптимизации различных портативных устройств. Разработанные методы можно применить и для улучшения энергоэффективности смартфонов. 
	
	В статье Маурицио предлагается глобально пересмотреть подход к производству с учетом интересов конечного пользователя~\parencite{маурицио2008переоценка}. А именно: изменить подбор архитектуры и уделять внимание экономии энергии на каждой стадии разработки продукта. При выборе архитектуры автор предлагает учитывать критерий энергопотребления, например, энергозатратные архитектуры, использующие ТПЛ и дифференциальные сигнальные методы со скоростью передачи данных более 10 Гбит/с, должны быть тщательно сопоставлены с менее энергоемкими методиками, такими как КМОП и использование несимметричных архитектур. В дополнение к данному подходу делается акцент на необходимости дальнейшей оптимизации уже существующих архитектур, дополняя их новыми характеристиками.
	
	Анализ энергопотребления и средней задержки для типового режима энергосбережения с несколькими циклами ожидания показал, что можно подбирать оптимальные параметры режимов ожидания с учетом ограничения средней начальной задержки~\parencite{пустовалов2013анализ}. Предложенная автором методика базируется на простой математической модели входного потока, которая применима и для сложных систем с большим числом состояний. Критерием её применимости является условие, при котором функционирование системы можно разбить на циклы регенерации.
	
	Также можно рассмотреть более частные случаи. Например, способы по оптимизации потребления энергии устройствами, основным элементом которых является микроконтроллер. Они нашли себе применение в том числе и в смартфонах. Обзор охватывает программные, архитектурные и схемотехнические способы снижения потребления~\parencite{кафтанников2013оптимизация}.
	
	Программные способы направлены на снижение вычислительной нагрузки на микропроцессор. Приведены такие способы, как использование специфичной математики, так как операции с дробными числами занимают продолжительное время. Также учёт разрядности процессора может сыграть существенную роль в снижении энергопотребления. Ещё один способ предполагает переписывание критичных участков кода на язык ассемблера, но это поставит крест на кроссплатформенности получившихся решений.
	
	Архитектурные способы применяются разработчиками микроконтроллера и к ним относится реализация различных режимов энергосбережения, что позволяет отключать неиспользуемую перифирию, а также снижать тактовую частоту процессора. Также отключение неиспользуемых узлов кристалла позволит в разы снизить потребление энергии.
	
	Схемотехнические методы оптимизации применимы к самой аккумуляторной батарее. Предлагается использование литий-ионных или литий-полимерных источников питания для обеспечения прямого питания схемы от батареи. Также предлагается различное напряжение питания для вычислительного ядра и периферии, но это приводит к снижении тактовой частоты микросхем.
	
	%Альтернативный взгляд на проблему --- признание важности влияния ПО на потребление энергии нижележащим аппаратным обеспечением. В работе А. В. Юрченко применяются иерархические энергетические меры, получаемые из граф-схемы программы~\parencite{юрченко2013проектирование}. Они использованы для определения количества выполненных инструкций и количества операций доступа к памяти данных. Основываясь на полученных мерах, были определены программные метрики энергоэффективности, используемые для оценки энергопотребления процессора и операций доступа к памяти данных и памяти команд. В дальнейшем необходимо определить более подробные, сложные метрики, которые помогли бы разработчикам создавать более качественное ПО в терминах энергопотребления.
	
	\subsection{Энергопотребление в операционной системе Android}

	Следующая предметная область, которая стоит отдельного упоминания в контексте моей выпускной квалификационной работы, --- энергопотребление в операционной системе Android, так как именно для оптимизации работы этой операционной системы будет использоваться результат моей работы.
	
	В статье В. М. Цветкова обсуждаются проблемы энергоэффективности мобильных устройств на ОС Android~\parencite{цветков2014энергоэффективность}. В частности необходимость снижения энергопотребления в моделях поведения датчиков и радиомодуля, за счёт сокращения числа SMS и отправки их только при хорошем сигнале, при конвертации flash-анимаций и с помощью умного проектирования интерфейса. Для преодоления этих проблем автор предлагает: 1) установить контроль потребления энергии датчиками и антенной связи; 2) осуществлять запись циклов flash-анимаций или её конвертацию на стороннем сервере в более энергоэкономичное решение; 3) компоновать SMS за несколько минут в один пакет и отправлять их только при хорошем сигнале; 4) увеличить долю тёмных цветов в интерфейсе для AMOLED-экранов; 5) прибегнуть к написанию Android-приложений на более низкоуровневых языках. Комплексное использование всех методов позволит улучшить показатели энергоэффективности почти в два раза и сделать Android более конкурентоспособной операционной системой.
	
	В статье  Ли и Халфонда была проведена эмпирическая оценка общепринятых методов кодирования энергосбережения и повышения производительности~\parencite{li2014investigation}. Она позволила определить, в какой степени эти методы смогли сэкономить энергию по сравнению с неоптимизированными аналогами кода. В частности, было обнаружено, что объединение сетевых пакетов до определенного размера и использование определенных методов кодирования для считывания информации о длине массива, доступа к полям классов и выполнения вызовов приводят к снижению энергопотребления. Однако другие методы, такие как ограничение использования памяти, оказали минимальное влияние на использование энергии. Эти результаты позволят разработчикам снизить общее энергопотребление и повысить удобство использования их приложений.
	
	Работа Ли, Хао и др. по сбору информации о поведении приложений в отношении энергопотребления выявила, что в среднем приложения тратят 60\% своей энергии в неактивных состояниях, сеть является наиболее энергоемким компонентом и только несколько API доминируют в энергопотреблении в рабочем состоянии~\parencite{li2014empirical}. Также они проанализировали три распространенных метода в исследованиях, связанных с энергией: использование времени работы для расчёта приближенного значения; использование измерения на уровне миллисекунд; и пренебрежение затратами энергией в состоянии покоя. Анализ этих методов показал, что они могут привести к большим неточностям в наблюдаемых данных и могут подорвать достоверность статистических исследований.
	
	\subsection{Оптимизация энергопотребления экранов мобильных устройств}
	
	Целевым компонентом результата моей дипломной работы --- системы для оптимизации энергопотребления элементов графического интерфейса --- является экран мобильного устройства. В связи с чем стоит рассмотреть ранее изученные подходы к энергооптимизации данного компонента.
	
	Исследования показывают, что потребление может быть уменьшено за счет снижения частоты кадров~\parencite{lee2018improving}, оптимизации сети~\parencite{tuysuz2019real}, использования памяти~\parencite{li2014investigation}, использования темного фона жидкокристаллических экранах~\parencite{утин2018адаптивное} и так далее. Эмпирическое исследование показывает, что смартфон потребляет большое количество энергии при отображении интерфейса для пользователя~\parencite{li2014empirical}. 
	
	Ван и Джин~\parencite{wan2015detecting} описали методику обнаружения энергоемких интерфейсов и их преобразования для экономии энергии. Их результаты оказали значительное влияние на оценку энергопотребления экрана и, кроме того, их идея была разработана в исследовании Линареса-Васкеса и др.~\parencite{linares2018multi}. Суть данного подхода основана на оптимизации цветовой палитры при сохранении допустимого уровня контрастности. Частота обновления дисплея также не ускользнула от внимания научного сообщества. Хуан и др.~\parencite{huang2014intelligent} и Ким и Юнг~\parencite{kim2014content} предполагают, что частота обновления является ключевым фактором для экономии энергии за счет снижения частоты обновления содержимого дисплея.
	
	Ключевой особенностью исследования Вана и Джина~\parencite{wan2015detecting} является инструмент, который может анализировать содержимое скриншота. Это модель потребляемой дисплеем мощности, которая предсказывает количество энергии, потребляемой каждым пикселем экрана, принимая во внимание тип экрана и цвет определенного пикселя. Позже оригинальный скриншот трансформируется, чтобы достичь более энергоэффективного пользовательского интерфейса. Преобразованное изображение аналогично анализируется перед сравнением результатов с исходными данными. Результаты работы ученых показывают, что предполагаемая экономия энергии достигает 50\% от первоначального значения. Оно указывает на то, что их идеи служат основой для дальнейшего изучения. Тем не менее, оценка погрешности модели была измерена только на 4 различных устройствах, которые могут не отражать полноту всей картины.
	
	В работе Линарес-Васкес и др.~\parencite{linares2018multi} основой подхода является многоцелевое рассмотрение контента. Это позволяет разработчикам достичь компромисса между тремя выделенными целями: снижение энергопотребления на OLED-дисплеях, увеличение контраста между соседними элементами пользовательского интерфейса и сохранение согласованности в использовании цветов по сравнению с оригинальным дизайном. Для достижения такого поведения необходимо найти состояние оптимальности по Парето, состояние, в котором улучшение одной из целевых функций не может быть достигнуто без ухудшения других целей. С помощью указанных методов ученым удалось в некоторых случаях снизить энергопотребление на 79\%. Этот результат представлен с множеством графически выраженных данных, которые иллюстрируют весь процесс. Вопрос, который остается нераскрытым --- это сопоставимость опыта пользователя до и после оптимизации питания.
	
	Хуан и др.~\parencite{huang2014intelligent}, в свою очередь, демонстрируют взаимосвязь между энергопотреблением и частотой обновления дисплея. В настоящее время частота обновления ЖК-экранов постоянна, что приводит к тому, что экрану приходится рисовать те же кадры без особой на то необходимости. Ученые представили механизм, сокращающий избыточные обновления кадров и доступ к памяти на основе знаний кадровых буферов. Тем не менее, из исследования невозможно сделать вывод об устройствах с типом экрана, отличным от LCD.
	
	В дополнение к вышеупомянутым исследованиям Ким и Юнг~\parencite{kim2014content} придерживались идеи интеллектуальной частоты обновления дисплея. Ключевой особенностью статьи является показатель скорости контента и его отношение к частоте обновления экрана. Предлагаемая метрика скорости контента начинается с определения частоты обновления контента для каждого приложения и затем управления частотой обновления, чтобы оптимизировать энергопотребление без ущерба для пользовательского восприятия. Измерение частоты обновления контента основано на частоте кадров и сравнении кадровых буферов разных кадров для вычитания избыточной частоты кадров. Кроме того, была применена технология ускорения касанием: частота обновления резко возрастает, когда происходит событие касания. Это исследование все еще имеет некоторые ограничения: только одна модель устройства была протестирована, а типы дисплеев, для которых исследование является действительным, не описаны.
	
	\subsection{Выводы}
	
	Проведенный обзор литературы показал, что на текущий момент проблема энергопотребления активно разрабатывается исследовательским сообществом. Авторы показали необходимость оптимизации ПО, разработки инновационных программных и аппаратных решений, а также учёта пользовательского восприятия. Тем не менее, остается открытым вопрос дальнейшей проработки решений, которые помогут повысить энергоэффективность дисплея как самого энергозатратного компонента смартфона.
	
	\newpage
	\section{Инструменты для измерения энергопотребления}
	
	Измерение энергопотребления приложения в конкретный момент или небольшой промежуток времени --- одна из самых важных и сложных задач, которую необходимо решить в ходе выполнения ВКР.
	
	Необходимость в проведении таких измерений связана с необходимостью формирования базы данных элементов пользовательского интерфейса и советов для их оптимизации. В ходе работы системы контроля и управления энергопотребления сформированная база элементов пользовательского интерфейса будет использоваться для сравнения данных по энергопотреблению текущих элементов с подобными по выполняемой функциональности и поиска наиболее энергоэффективных альтернатив.
	
	\subsection{Методология измерений}
	
	Сложность проведения измерений энергопотребления приложения заключается в наличии большого количество факторов, влияющих на показатели энергопотребления, которые не связаны непосредственно с работой приложения. Такими факторами могут быть другие приложения, выполняющие работу в фоновом режиме, задачи операционной системы, а также особенности конкретного устройства. Избавиться от влияния всех факторов не представляется возможным, однако для уменьшения их влияния можно предпринять следующие меры:
	\begin{itemize}
		\item проводить тестирование на устройстве без сторонних приложений;
		\item проводить тестирование на устройстве с операционной системой без сервисов Google Play Services, которые выполняют фоновые задачи операционной системы;
		\item проводить тестирование всех элементов интерфейса на одном и том же устройстве;
		\item проводить тестирование при активированном на устройстве режиме полёта;
		\item проводить тестирование с максимальной яркостью экрана.
	\end{itemize}

	Несмотря на то, что данные меры снижают погрешность при измерениях, они её не исключают. Поэтому необходимо будет провести несколько измерений и дополнительно обработать результаты, чтобы избавиться от статистических выбросов.
	
	\subsection{Способы измерения}
	
	Для получения энергопотребления конкретного приложения могут быть использованы следующие подходы:
	\begin{itemize}
		\item анализ напряжения на аккумуляторе, получаемого через компонент приложения BroadcastReceiver;
		\item получение данных по энергопотреблению с помощью инструмента Android Profiler;
		\item анализ данных по конкретному приложению, собираемых операционной системой, с помощью инструмента Battery Historian;
		\item анализ напряжения на аккумуляторе, собираемых операционной системой, с помощью Battery Historian;
		\item измерение энергопотребления всего устройства с помощью стороннего оборудования.
	\end{itemize}

	Анализ напряжения, получаемого через BroadcastReceiver страдает от несовершенности API. Разные устройства могут иметь различное поведение относительно частоты обновления данных, но в среднем новое значение рассылается при уменьшении заряда аккумулятора на один процент. То есть данный подход позволяет получить лишь около 100 значений за время полного разряда устройства, чего не хватит для анализа.
	
	Android Profiler и Battery Historian позволяют фильтровать потребление по отдельному приложению, что несомненно является преимуществом. Но Android Profiler не учитывает потребляемую экраном энергию и показывает лишь потребление по четырёхзначной шкале (None, Low, Meduim, High) следующих потребителей: процессор, сеть, геолокация. Этого может быть недостаточно для полноценного анализа.
	
	Battery Historian отображает более точную информацию о потреблении конкретным приложением. Доступна информация по проценту израсходованной батареи, а также процессорное время, использованное приложением. Но доступны только суммарные данные за всё время с последней полной зарядки устройства. То есть нельзя сказать, сколько потребляло приложение в конкретный момент времени. Так как тесты проводятся в рамках одного приложения, использовать Battery Historian без модификаций не получится. 
	
	Данные по напряжению в Battery Historian доступны по временным промежуткам, но они довольно хаотичны \ris{\ref{fig:historian_voltage}} и без информации о силе тока, ничего извлечь из них не получится.
	
	\begin{figure}[htb]
		\includegraphics[width=\textwidth]{historian_voltage}
		\caption{Напряжение на аккумуляторе устройства}
		\label{fig:historian_voltage}
	\end{figure}

	Из-за недостатков остальных подходов, изначальный выбор был сделан в пользу измерения энергопотребления с помощью стороннего оборудования.
	
	\subsection{Обоснование выбранного инструмента}
	
	Самым надёжным способом в настоящий момент остаётся измерение потребления всего устройства с помощью стороннего оборудования. Данный подход используется практически всеми современными исследованиями, требующими измерения энергопотребления приложения. Устройство для измерения подключается к тестируемому устройству вместо аккумуляторной батареи и записывает показатели потребляемой устройством мощности с некоторым интервалом. Устройства для измерения варьируются от платы Arduino с небольшой программой до оборудования, специально созданного для таких целей. Самым популярным решением является использование Monsoon Power Monitor, именно его я собирался использовать при проведении собственных измерений.
	
	К сожалению, доставка устройства или его аналогов не представляется возможным, в связи с чем, при измерениях придётся данные операционной системы.
	
	Данные ОС выводит в текстовом виде, после чего они могут быть загружены для анализа в Battery Historian. Но так как файлы текстовые, для более эффективного анализа они могут быть проанализированы собственными алгоритмами. Мне не удалось найти документации к содержимому файлов, поэтому формат их содержимого пришлось анализировать самостоятельно.
	
	\subsection{Анализ системных отчётов}
	
	В Battery Historian загружается zip-архив, получаемый через Android Debug Bridge командой \textbf{adb bugreport}. Его следует проанализировать в первую очередь.
	
	\subsubsection{Анализ архива отчёта}
	
	При распаковке архива мы получаем директорию c файлами, описанными в документации~\parencite{BugreportFormat}:
	\begin{itemize}
		\item bugreport-OnePlus3-PKQ1.181203.001-2020-05-13-12-21-11.txt --- самый большой по занимаемому дисковому пространству файл, содержащий всю основную информацию;
		\item FS --- директория с некоторыми данными из файловой системы устройства;
		\item dumpstate\_log.txt --- файл, содержащий информацию о том, как прошёл сбор данных;
		\item lshal-debug --- директория с информацией о слоях аппаратных абстракций операционной системы;
		\item main\_entry.txt --- файл, содержащий имя файла с основными данными, в данном случае, первого в списке файла;
		\item proto --- информация от вспомогательных служб в proto-формате;
		\item version.txt --- файл с версией формата отчёта.
	\end{itemize}

	После изучения директории становится понятно, что единственный файл, представляющий интерес --- первый в списке.  При открытии файла мы видим шапку с информацией о модели устройства, версии ядра операционной системы и так далее \ris{\ref{fig:report_header}}. После этого упоминается вызов инструмента \textbf{dumpsys} и представлены разделённые на блоки отчёты различных служб. 
	
	\begin{figure}[!htb]
		\includegraphics[width=\textwidth]{report_header}
		\caption{Шапка отчёта устройства}
		\label{fig:report_header}
	\end{figure}

	\subsubsection{Инструмент dumpsys} \label{subsub:dumpsys}
	
	Из найденной документации к \textbf{dumpsys}~\parencite{Dumpsys} становится понятно, что отчёты служб можно получать по отдельности, что удобно, так как понадобится далеко не вся информация. В ней же можно найти команду \textbf{adb shell dumpsys batterystats}, которая возвращает статистику по расходу заряда батареи устройства. Возвращаемый файл достаточно объёмный, наибольший интерес представляет раздел \textbf{Statistics since last charge}, так как он содержит информацию по конкретным приложениям.
	
	В подразделе \textbf{Estimated power use (mAh)} отображаются затраты, разделённые на Uid~\ris{\ref{fig:estimated_use}}. Uid --- это пользовательский идентификатор в Unix-подобных операционных системах, он уникален для каждого приложения и по нему можно отслеживать энергопотребление и затраченное процессорное время.
	
	\begin{figure}[!htb]
		\includegraphics[width=\textwidth]{estimated_use}
		\caption{Подраздел с затратами на каждый Uid}
		\label{fig:estimated_use}
	\end{figure}
	
	Также в разделе есть подраздел с общей статистикой для каждого Uid в системе, там не указана израсходованная энергия, но есть информация о процессорном времени, потраченным на это приложение~\ris{\ref{fig:uid_subsection}}.

	\begin{figure}[!htb]
		\includegraphics[width=\textwidth]{uid_subsection}
		\caption{Подраздел со статистикой по Uid u0a662}
		\label{fig:uid_subsection}
	\end{figure}

	Также была использована служба \textbf{cpuinfo}, предоставляющая дополнительную информацию о затраченном процессорном времени. Обычно сервис предоставляет незначительную информацию, но в отчётах устройства, используемого для тестирования (OnePlus A3000), имелись дополнительные данные, разделённые по времени и Uid, что предоставляет возможности для дополнительного анализа~\ris{\ref{fig:cpuinfo}}.
	
	\begin{figure}[H]
		\includegraphics[width=\textwidth]{cpuinfo}
		\caption{Дополнительная информация сервиса cpuinfo на устройстве OnePlus A3000}
		\label{fig:cpuinfo}
	\end{figure}

	Последняя проблема, требующая решения, --- это то, что \textbf{batterystats} показывает только суммарные данные за время с последней полной зарядки устройства, что мешает получать данные по конкретному виджету. Для её решения была использована команда \textbf{adb shell dumpsys batterystats -{}-reset}, которая помогает вручную сбросить все имеющиеся данные и начать запись сначала. Если собирать информацию после тестирования виджета и сбрасывать её до тестирования следующего, то полученные данные будут отражать статистику по конкретному виджету.
	
	\newpage
	\section{Измерение энергопотребления}
	
	До начала всех измерений необходимо конкретизировать круг всех элементов интерфейса, с которыми итоговая система будет корректно работать.
	
	\subsection{Составление списка элементов}
	
	Было решено использовать только те виджеты, которые могут быть отображены без взаимодействия с другими виджетами, следовательно, могут быть измерены отдельно от всего остального. В противном случае, было бы необходимо измерять виджеты во всех возможных условиях, а это бы в разы увеличило время проведения тестов.
	
	Для составления списка элементов был взят список всех сущностей в пакете android.widget в Android SDK Platform (29 API). После этого из списка были исключены следующие сущности:
	\begin{itemize}
		\item deprecated классы, так как они не рекомендуются к использованию разработчиками ОС и в будущих версиях могут быть удалены;
		\item интерфейсы и классы-адаптеры, так как они не являются виджетами;
		\item абстрактные классы, так как невозможно создать объект такого класса;
		\item вспомогательные классы, так как они не являются виджетами;
		\item виджеты, требующие наличие адаптера или презентера для отображения;
		\item наследники представлений, задачей которых является позиционирование других представлений, добавленных к текущему.
	\end{itemize}
	
	После этого остался список самостоятельных элементов, для которых необходимо написать программу тестирования.
	
	\subsection{Автоматизирование}
	
	Ручное проведение измерений потребует огромного количества времени для переключения экранов с различными элементами интерфейса, а также данное переключение будет неточным и может исказить результаты. Поэтому необходимо разработать средства, позволяющие автоматизировать процесс измерения потребления.
	
	Чтобы управлять сменой виджетов на экране, был выбран инструментарий для автоматического тестирования графического интерфейса. Он позволяет имитировать реальное взаимодействие пользователя с устройством. В этой работе пользовательские действия не будут имитированы, но это может понадобится для дальнейших исследований.
	
	\subsubsection{Проектирование автоматических тестов}
	
	Автоматические тесты графического интерфейса помогут менять виджеты на экране через определённые промежутки времени. Это избавляет от необходимости ручного управления переключением элементов и искажений, которые накладывает ручное переключение.
	
	Некоторые элементы, например TextView или ImageView, требуют наполнения каким-нибудь содержимым, чтобы отображаться на экране. Некоторые элементы требуют менее тривиальных манипуляций перед отображением. Чтобы унифицировать процесс обработки элемента перед и после добавления на экран, было принято решение создать класс ViewWrapper, который будет содержать класс требуемого представления, а также методы beforeAdd и afterAdd, которые будут вызваны до добавления на экран и после добавления на экран соответственно. 
	
	{\huge TODO неактуально}
	Если элементу требуются дополнительные действия, как в примерах выше, методы могут быть переопределены в наследниках класса ViewWrapper. При выполнении тестов в цикле для каждого виджета производятся следующий действия:
	\begin{enumerate}
		\item Создаётся объект класса представления, содержащегося в объекте ViewWrapper.
		\item Activity очищается от всех отображаемых элементов.
		\item Вызывается метод beforeAdd для созданного объекта.
		\item Объект представления добавляется в Activity для отображения.
		\item Вызывается метод afterAdd для добавленного объекта.
		\item Приостановка выполнения на десять минут.
	\end{enumerate}
	
	\subsubsection{Язык программирования и  инструментальные средства}
	
	Для того, чтобы упростить и унифицировать процесс измерения, необходимо написать программу, управляющую поведением устройства во время проведения измерений.
	
	Как стало понятно в разделе \ref{subsub:dumpsys}, между переключением элементов нужно обращаться к командной оболочке операционной системы устройства, чтобы записывать статистику по протестированному элементу на компьютер и сбросить её перед тестированием следующего.
	
	В теории, это может быть сделано двумя способами: обращением к командной оболочке из самого приложения, либо обращением к оболочке через средства Android Debug Bridge с компьютера. При проверке оказалось, что первый вариант невозможен, так как требует особого разрешения операционной системы, которое не выдаётся сторонним приложениям~\parencite{Dump_Permission}. Поэтому сбор и сброс статистики необходимо осуществлять через Android Debug Bridge. Автоматические тесты неспособны исполнять какие-либо команды на устройстве, которое их запустило, потому что они загружаются на смартфон и исполняются полностью на нём, отчитываясь лишь логами и статусом завершения теста. Отсюда можно сделать вывод, что тестом должен управлять shell-скрипт на компьютере, который будет в цикле запускать измерения с нужным виджетом.
	
	{\huge TODO раздел}
	
	 Первая проблема заключается в передаче номера тестируемого виджета автотесту, который отображает виджет. По умолчанию возможности передавать собственные данные из команды запуска теста в код теста не имеется, но её можно добавить, расширив класс Instrumentation. По умолчанию, в приложении используется класс AndroidJUnitRunner в качестве Instrumentation, поэтому мой класс MyTestRunner будет наследовать и расширять возможности AndroidJUnitRunner~\ris{\ref{fig:mytestrunner}}.
	 
	 \begin{figure}[tbh]
	 	\includegraphics[width=\textwidth]{mytestrunner}
	 	\vspace{-0.7cm}
	 	\caption{Листинг класса MyTestRunner}
	 	\label{fig:mytestrunner}
	 \end{figure}
 
 	Было решено передавать в тест 2 параметра: индекс виджета и время его тестирования. Время будет удобнее определять в единственном месте, этим местом будет shell-скрипт. После этого остаётся в файле build.gradle сменить testInstrumentationRunner на написанный com.yundin.estimation.MyTestRunner.
	
	{\huge TODO раздел}
	
	Далее необходимо выбрать конкретный инструмент, позволяющий писать тесты пользовательского интерфейса Android, рассмотрим варианты:
	\begin{itemize}
		\item appium;
		\item espresso;
		\item kakao;
		\item kaspresso.
	\end{itemize}
	
	Appium не является подходящим, так как он не всегда стабильно работает, а также не поддерживает старые версии Android. 
	
	У Espresso подобные проблемы отсутствуют, но присутствует проблема с избыточностью синтаксиса и нечитаемости итогового кода. 
	
	Kakao и Kaspresso в свою очередь основываются на Espresso, но каждый по-своему исправляет избыточность синтаксиса с помощью возможностей языка Kotlin, но Kaspresso имеет расширенную функциональность, поэтому был выбран данный фреймворк.
	
	{\huge TODO раздел}
	
	Была обнаружена проблема с тем, что когда устройство находится в режиме зарядки, сбор статистики разряда устройства приостанавливается. Для работы скрипта необходимо постоянное подключение устройства к управляющему процессом компьютеру. Это может быть либо подключение по проводу, либо через локальную сеть, когда устройства подключены к одной точке доступа. В первом случае устройство находится в состоянии зарядки, во втором случае оно имеет доступ к интернету, что не позволит устройству находится в режиме полёта и может сильно исказить результаты при обращении других приложений к сети.
	
	Была найдена возможность искусственно выключать режим зарядки на устройстве командой \textbf{adb shell dumpsys battery set usb 0}. После команды устройство продолжает заряжаться, но ведёт себя так, будто не заряжается. Очевидно, что в этом случае результаты также могут искажаться, поэтому было произведено тестирование.
	
	Изначально нужно создать как можно более близкие условия для сравнения, а именно:
	\begin{itemize}
		\item Устройство должно быть в режиме полёта;
		\item Все посторонние приложения закрыты;
		\item Запускается Activity и больше никакого взаимодействия с устройством до окончания теста не производится.
	\end{itemize}

	Только запуск Activity будет происходить разными способами. Когда нет подключения к компьютеру, последовательность действий следующая:
	\begin{enumerate}
		\item Закрытие всех приложений;
		\item Включение режима полёта;
		\item Подключение устройства к компьютеру;
		\item Сброс статистики;
		\item Отключение устройства от компьютера;
		\item Запуск приложения через нажатие на его иконку в списке всех приложений;
		\item По окончанию тестирования подключение к компьютеру и запись статистики.
	\end{enumerate}

	В случае подключения к компьютеру:
	\begin{enumerate}
		\item Закрытие всех приложений;
		\item Включение режима полёта;
		\item Подключение устройства к компьютеру;
		\item Выход из режима зарядки;
		\item Очистка статистики;
		\item Запуск приложения командой \textbf{adb shell am start -n "com.yundin.estimation/com.yundin.estimation.MainActivity"};
		\item По окончанию тестирования запись статистики.
	\end{enumerate}

	Каждый сценарий повторяется трижды, чтобы увидеть искажения от подключения к сети, а также разницу между измерениями, проведёнными по одному сценарию.
	
	Однако запустить автоматические тесты без подключения к компьютеру не получится. Появляется необходимость запускать тестирование не только через автоматические тесты, но и с запуском Activity.
	
	{\huge TODO раздел}
	
	Написание кода стоит начать с написания наследников класса ViewWrapper, которые будут наполнять виджеты минимальным содержимым \ris{\ref{fig:wrapper}}. После этого формируется массив, содержащий объект ViewWrapper для каждого тестируемого виджета.
	
	\begin{figure}[tbh]
		\includegraphics[width=\textwidth]{wrapper}
		\caption{Листинг класса ViewWrapper и части его наследников}
		\label{fig:wrapper}
	\end{figure}

	Процесс создания объекта виджета и его добавления к Activity должны быть одинаковы при тестировании через запуск автотеста и через запуск Activity, более подробно эта необходимость объяснена в разделе \textbf{TODO ref}.
	
	Для достижения такого поведения, именно Activity на стадии своей инициализации должна устанавливать нужный виджет на экран. После чего Activity должна ждать столько, сколько нужно для тестирования виджета, и завершаться. Передать информацию об индексе нужного виджета, а также о времени тестирования можно единственным способом: через объект Intent, с помощью которого происходит запуск Activity. При создании класса Activity создаётся массив всех ViewWrapper. В методе onCreate Activity получает необходимые данных из объекта Intent, создаёт объект класса нужного виджета, устанавливает его в качестве своего наполнения, а также создаёт отложенную задачу на своё завершения, которую помещает в очередь сообщений главного потока. Последнее действие нужно потому, что метод onCreate всегда вызывается в том же потоке исполнения, в котором происходит отрисовка пользовательского интерфейса, и если заставить поток ждать, виджет не будет отображён на экране.
	
	Теперь для запуска измерений нужного виджета через автотест, необходимо лишь сконфигурировать Intent запуска Activity, запустить её и не завершать поток исполнения автотеста до завершения тестирования. Если поток автотеста завершится сразу после запуска Activity, то завершится и сама Activity. Так как в данном случае не имитируется взаимодействие пользователя с виджетом, поток не выполняет никакой работы, а просто ожидает.
	
	{\huge TODO раздел}
	
	Сам проект будет удобно разделить на несколько модулей, чтобы хранить весь код в одном проекте. Модуль estimation содержит весь код, необходимый для проведения измерений. Модуль hierarchy-checker содержит код встраиваемой библиотеки. Модуль example подключает модуль hierarchy-checker и демонстрирует работу библиотеки.
	
	Модуль estimation в корневой директории содержит все используемые скрипты, а также результаты измерений. В директории src/androidTest содержится класс MyTestRunner, а также код автотестов. В директории src/main находятся наследники ViewWrapper, а также класс MainActivity.
	
	{\huge TODO раздел}
	
	Здесь и далее тестирование проводится на устройстве OnePlus A3000 с операционной системой Android 9 и версией ядра 3.18.120-perf+.
	
	\begin{figure}[tbh]
		\includegraphics[width=\textwidth]{usb_comparation}
		\caption{Результаты сравнения  сценариев измерения. Красные столбцы --- 3 измерения с подключенным кабелем. Синие столбцы --- к устройству ничего не подключено.}
		\label{fig:usb_comparation}
	\end{figure}

	Сравнение показало, что результаты измерения по разным сценариям достаточно сильно отличаются~\ris{\ref{fig:usb_comparation}}, но разница между измерениями без подключения к компьютеру также довольно большая и такому способу доверять сложно. В то же время при подключенном кабеле результаты сравнительно стабильные.
	
	Так как в данном случае не будет имитироваться взаимодействие с пользователем, проводить измерения с помощью автотестов необязательно, можно сразу запускать Activity, передавая нужные параметры. Необходимо сравнить между собой сценарий измерения с использованием автотестов и с запуском Activity напрямую.
	
	Сценарий измерения с помощью автотеста:
	\begin{enumerate}
		\item Закрытие всех приложений;
		\item Включение режима полёта;
		\item Подключение устройства к компьютеру;
		\item Выход из режима зарядки командой \textbf{adb shell dumpsys battery set usb 0};
		\item Очистка статистики командой \textbf{adb shell dumpsys batterystats -{}-reset};
		\item Запуск автотеста командой \textbf{adb shell am instrument -w -e class com.yundin.estimation.EstimationTest\#testViewByIndex -e index 0 -e time 180000 com.yundin.estimation.test/com.yundin.estimation.MyTestRunner};
		\item Запись статистики.
	\end{enumerate}
	
	Так как команда \textbf{adb shell am instrument -w} не вернёт управление, пока не окончится тест, можно не ждать и после её завершения сразу записывать собранную статистику. Для тестирование данным образом был написан скрипт.
	
	Сценарий измерения с помощью Activity:
	\begin{enumerate}
		\item Закрытие всех приложений;
		\item Включение режима полёта;
		\item Подключение устройства к компьютеру;
		\item Выход из режима зарядки командой \textbf{adb shell dumpsys battery set usb 0};
		\item Очистка статистики командой \textbf{adb shell dumpsys batterystats -{}-reset};
		\item Запуск Activity командой \textbf{adb shell am start -n "com.yundin.estimation/com.yundin.estimation.MainActivity" -{}-ei index 0 -{}-ei delay 180000};
		\item Пауза на 180 секунд;
		\item Запись статистики.
	\end{enumerate}

	В этом сценарии команда \textbf{adb shell am start} вернёт управление сразу же и требуется ожидание завершения теста.
	
	Стоит отметить, что с точки зрения Activity эти сценарии совершенно ничем не отличаются. Она запускается одинаковым образом и совершает одинаковые действия.
	
	\begin{figure}[tbh]
		\includegraphics[width=\textwidth]{test_comparation}
		\caption{Результаты сравнения  сценариев измерения. Красные столбцы --- измерения, запущенные через Activity. Синие столбцы --- измерения, запущенные через автотест.}
		\label{fig:test_comparation}
	\end{figure}

	Результаты представлены на рис. \ref{fig:test_comparation}. Видно, что измерения, запущенные через автотесты, тратят больше энергии, что можно объяснить издержками на дополнительный поток и исполнение дополнительного кода, запускающего процесс тестирования. Также между результатами трёх одинаковых измерений, запущенных через автотесты, есть существенная разница. Причиной этому могут быть индивидуальные особенности используемого устройства или установленной операционной системы.
	
	Сравнение сценариев измерения показало, что стабильней всего себя показывает вызов Activity напрямую при подключенном usb-кабеле. Для реализации данного сценария для всех виджетов был написан zsh-скрипт activity\_estimation.sh~\ris{\ref{fig:activity_estimation}}
	
	\begin{figure}[tbh]
		\includegraphics[width=\textwidth]{activity_estimation}
		\caption{Листинг части скрипта activity\_estimation.sh}
		\label{fig:activity_estimation}
	\end{figure}

	В скрипте цикл для каждого виджета сбрасывает статистику батареи, запоминает время начала теста, запускает тестирование, производит обратный отсчёт до окончания теста плюс одну секунду, после чего записывает время окончания теста, а также собранную статистику. После выполнения измерений для каждого виджета, записывается статистика процессора.
	
	Запись времени начала и конца, необходимо, чтобы найти результат тестирования в статистике процессора. Она не сбрасывается вместе со статистикой батареи, поэтому необходимо записать время, в которое проводился тест в файл со статистикой. Статистика процессора отображается за промежуток в последние несколько суток.
	
	После проведения тестов нужно будет из больших файлов с отчётами вычленить информацию, которая относится к тестируемому приложению. Делать это вручную для 54 файлов очень тяжело, поэтому на языке python были написаны 2 скрипта для фильтрации данных от служб \textbf{batterystats} и \textbf{cpuinfo}.
	
	Также написан скрипт concat\_filtered.sh. Из ранее отфильтрованных данных он исключает все подробности, кроме общего количества затраченных mAh, а также общего процессорного времени. Также происходит сбор данных для всех виджетов в один файл.
	
	Скрипт sum\_cpu.py помогает просуммировать процессорное время, потраченное системой и пользователем на работу приложения. Изначально данные представлены в человекочитаемом формате (например, \textbf{u=240ms s=50ms}), но компьютер сравнивать такие строки не сможет. Скрипт переводит данную строку в количество миллисекунд и записывает следующей строкой.
	
	Скрипт median.py подставляет реальные имена виджетов и считает медианное значение всех измерений. Используется именно медианное значение, так как из тестов сценариев понятно, что могут наблюдаться выбросы, сильно искажающие среднее значение. 
	
	И наконец скрипт chart.py сортирует результаты разных виджетов по затраченному процессорному времени и отображает в виде диаграммы.
	
	В ходе тестирования было обнаружено, что тестируемое приложение не отображается в логах службы cpuinfo. Это может быть связано с низкими значениями затрат процессорного времени. Информация этой службы в будущем использована не будет.
	
	Время измерения каждого виджета было установлено на 5 минут и было произведено 3 измерения для каждого виджета.
	
	\newpage
	\section{Результаты измерений}
	
	После проведения всех измерений и обработки результатов получилась диаграмма, представленная на рис. \ref{fig:result} и \ref{fig:result_scaled}.
	
	\begin{figure}[!htb]
		\includegraphics[width=\textwidth]{result}
		\caption{Результаты измерений. Синие столбцы --- процессорное время в мс. Красные столбцы --- количество затраченных mAh.}
		\label{fig:result}
	\end{figure}

	\begin{figure}[!htb]
		\includegraphics[width=\textwidth]{result_scaled}
		\caption{Результаты измерений. Синие столбцы --- процессорное время в мс. Красные столбцы --- количество затраченных mAh.}
		\label{fig:result_scaled}
	\end{figure}

	Видно, что виджет ProgressBar тратит энергии в десятки раз больше остальных виджетов. это неудивительно, потому что он проигрывает непрекращающуюся анимацию, которая требует постоянных расчётов и обновления содержимого экрана. Также в движении находится VideoView, которая воспроизводит видеофрагмент, но показатели его потребления не выбиваются из ряда остальных.
	
	Из результатов можно сделать и более неожиданные выводы. Например, виджет Space, заявленный как легковесное View, на деле потребляет больше ресурсов устройства, чем класс View. MultiAutoCompleteTextView потребляет ощутимо меньше энергии, чем подобные ему AutoCompleteTextView, и даже EditText.

	
	На графике неестественно выглядят показатели потребления TextSwitcher, так как выбиваются из сортировки. Произошло это из-за выброса показателя потребления в одном из измерений, процессорное время отображает более реальные данные.
	
	На основании этих данных удалось составить рекомендацию по оптимизации для 23 виджетов из 27 представленных. Некоторые виджеты не имеют аналогов или уже являются наиболее оптимальными среди аналогичных.
	
	\newpage
	\section{Подключаемая библиотека}
	
	Теперь можно приступить к написанию непосредственно библиотеки, которая и будет являться конечным результатом работы.
	
	\subsection{Проектирование библиотеки}
	
	Перед написанием кода подключаемой библиотеки, необходимо её спроектировать. Проектирование поможет сделать работу библиотеки более стабильной и готовой к различным изменениям. К тому же, на хорошо спроектированные модули гораздо легче написать тесты при необходимости. 
	
	Задача проектирования заключается в продумывании архитектуры программного продукта, то есть описания того, из каких частей он будет состоять и как они будут между собой связаны. В моём случае библиотека выполняет следующие действия:
	\begin{itemize}
		\item прослушивание событий открытия нового экрана;
		\item прослушивание событий добавления новых элементов на текущий экран;
		\item сравнение заданного элемента интерфейса с его альтернативами на основании базы данных;
		\item вывод результата.
	\end{itemize}
	Изначально кажется, что первые две задачи очень похожи, но на деле это не совсем так, потому что за это отвечают разные механизмы и новый экран может быть открыт несколькими разными способами. Поэтому было решено разделить библиотеку на следующие модули:
	\begin{itemize}
		\item UIManager – точка входа в программу, которой необходим объект класса Application для установления слушателей открытия нового экрана. Здесь же определяются, какие реализации остальных компонентов будут использованы в работе.
		\item HierarchyAnalyzer – абстракция с методом analyzeDynamicHierarchy и полями типа Adviser и RecommendationOutputter. Этот класс будет слушать изменения в существующих иерархиях элементов, обращаясь к Adviser, чтобы сравнить элемент с имеющимися в базе данных и к RecommendationOutputter, чтобы вывести полученный результат.
		\item Adviser абстракция с методом, который ищет оптимальный элемент, подобный заданному. Может возникнуть необходимость делать это асинхронно, так как поиск будет связан с работой с базой данных, поэтому метод findAlternativeAsync помимо имени класса элемента принимает callback, через который будет возвращён результат.
		\item RecommendationOutputter абстракция с методом output, принимающим оригинальный элемент интерфейса и строку с описанием альтернативы.
	\end{itemize}
	
	\subsection{Язык программирования и  инструментальные средства}
	
	Теперь нужно определиться, какими инструментами предстоит пользоваться при написании кода библиотеки. Самое основное --- язык написания. Для разработки встраиваемой библиотеки необходимо использовать язык программирования Java и/или Kotlin. Дополнительно могут быть использованы модули, скомпилированные в .so файл, и написанные на любом языке, поддерживающие такую компиляцию. 
	
	Нет необходимости пользоваться возможностью подключения .so файлов в данном проекте, так как задачи обеспечения повышенной производительности или потребности в более тонком управлении памятью здесь не стоит. Языки Kotlin и Java не имеют разницы в производительности, так как в итоге компилируются в одинаковый байт-код. Вопрос только в удобстве написания, и здесь в большинстве случаев выигрывает Kotlin, позволяющий писать код более короткий и более читаемый для человека код. Так как эти языки совместимы, при необходимости можно будет написать фрагмент программы на языке Java, но основным языком разработки я выбрал Kotlin.
	
	Так как языки Java и Kotlin совместимы, я могу для написания собственной библиотеки использовать другие библиотеки, написанные как на языке Java, так и на языке Kotlin. Сторонние библиотеки могут упростить прослушивание событий, работу с базой данных, реализацию алгоритмов сравнения элементов друг с другом и так далее. Но чтобы не увеличивать размер библиотеки и не добавлять в неё функциональность из сторонней библиотеки, которая не будет использована, я решил пользоваться только средствами Android SDK, а также языков Java и Kotlin.
	
	В библиотеке мне предстоит отслеживать смену экранов и динамическое изменение иерархий элементов, в Android SDK для этого имеются такие средства как Application.ActivityLifecycleCallbacks, FragmentManager.FragmentLifecycleCallbacks и ViewGroup.OnHierarchyChangeListener. ActivityLifecycleCallbacks используются для отслеживания изменений состояния жизненного цикла Activity, его удобно использовать, чтобы определять, что создалась новая сущность Activity (для этой сущности будет вызван метод жизненного цикла onCreate). FragmentLifecycleCallbacks может использоваться для отслеживания жизненного цикла Fragment (компонент, который может представлять собой отдельный экран или его часть). OnHierarchyChangeListener в свою очередь позволяет отслеживать динамические изменения иерархии элементов графического интерфейса.
	
	Так как ViewGroup.OnHierarchyChangeListener полностью покрывает все текущие сценарии использования FragmentManager.FragmentLifecycleCallbacks, было решено сипользовать Application.ActivityLifecycleCallbacks для определения появления новых Activity вместе с ViewGroup.OnHierarchyChangeListener, чтобы находить новые сущности Fragment и вручную добавляемые программистом представления.
	
	\subsection{База данных}
	
	Базу данных решено было спроектировать следующим образом. Существует одна таблица с тремя столбцами. В первом столбце содержится id строки, это поле обязательно. Второй столбец содержит название виджета, для которого в третьем столбце находится название самого близкого по потреблению аналога. Идея в том, чтобы получать самый близкий аналог, потребляющий меньше текущего и выполнять новый поиск для полученного аналога. Таким образом, поиск будет производится до тех пор, пока мы не получим виджет, не имеющий более энергоэффективных аналогов. Результатом станет полный список виджетов, которыми можно заменить текущий виджет, чтобы повысить энергоэффективность приложения.
	
	Иногда нужно дописать какое-либо дополнение к замене, в таких случаях первым словом будет название виджета, а после него дополнение, которое будет добавляться к каждому последующему виджету.
	
	База данных содержит рекомендации по замене следующих виджетов:
	\begin{itemize}
		\item ProgressBar --- Switch
		\item DatePicker --- CalendarView
		\item TimePicker --- AutoCompleteTextView
		\item AutoCompleteTextView – EditText
		\item CalendarView --- EditText
		\item RadioButton --- Switch with custom logic
		\item Switch --- CheckBox
		\item CheckBox --- TextSwitcher
		\item SearchView --- EditText
		\item NumberPicker --- SeekBar
		\item ImageButton --- ImageSwitcher
		\item SeekBar --- EditText
		\item TextSwitcher --- ImageSwitcher
		\item RatingBar --- EditText
		\item EditText --- MultiAutoCompleteTextView
		\item ImageSwitcher --- ToggleButton
		\item Space --- View
		\item Button --- TextView
		\item TextView --- ImageView
		\item MultiAutoCompleteTextView --- ToggleButton
		\item ImageView --- CheckedTextView
		\item ToggleButton --- CheckedTextView
		\item CheckedTextView --- View with background
	\end{itemize}

	Созданная база данных помещена в директорию assets модуля hierarchy-checker, чтобы иметь доступ к бинарному файлу базы из библиотеки.

	\subsection{Разработка}
	
	При написании кода я решил начать с описания спроектированной архитектуры в синтаксисе языка программирования Kotlin. UIManager – singleton-объект, содержащий методы init и getActivityRoot. Первый ---  точка входа в приложение, он принимает объект приложения и ничего не возвращает. getActivityRoot принимает на вход объект Activity и возвращает корневое представление иерархии, привязанное к этому Activity. Adviser – интерфейс с методом findAlternativeAsync, который принимает имя класса представления, которое необходимо проанализировать, а также callback, через который будет возвращён результат, если он будет. RecommendationOutputter тоже интерфейс с методом output, принимающим объект View, для которого сформирована рекомендация и сама рекомендация в виде строки. HierarchyAnalyzer ---  абстрактный класс, так как у него имеется конструктор, принимающий реализации Adviser и RecommendationOutputter и сохраняющий их в поля на уровне абстрактного класса. Также он HierarchyAnalyzer содержит абстрактный метод analyzeDynamicHierarchy, который принимает корень иерархии элементов, которую необходимо проанализировать.
	
	Реализация HierarchyAnalyzer содержит объект OnHierarchyChangeListener, который она передаёт всем объектам ViewGroup, встречающимся в иерархии. Для прохода иерархии используется итерирование по всем дочерним элементам корневого элемента и рекурсивного вызова analyzeDynamicHierarchy в случае, если один из дочерних элементов теоретически может содержать дочерние элементы. Реализация OnHierarchyChangeListener вызывает метод analyzeDynamicHierarchy для каждого динамически добавленного элемента.
	
	В качестве реализации интерфейса RecommendationOutputter используется LogOutputter, выводящий информацию в логи устройства. При вызове метода output реализация проходит по всем родительским элементам, чтобы составить полный адрес текущего элемента в иерархии. Для смены порядка родительских элементов (идём снизу вверх по иерархии, выводим её сверху вниз) используется стек. После этого формируется сообщение, содержащее класс объекта, его расположение в иерархии и совет по оптимизации. Сообщение выводится в логи устройства.
	
	Класс DatabaseAdviser реализует интерфейс Adviser и содержит в поле класса объект AdviceHelper, который абстрагирует взаимодействие с базой данных, а также ThreadPoolExecutor, который сохраняет несколько потоков исполнения, которые могут быть многоразово использованы или завершены, если дополнительных задач не поступает в течение 30 секунд. Предполагается, что его использование сократит издержки на создание новых потоков за счёт переиспользования уже существующих. При вызове метода findAlternativeAsync на потоке, который предоставляет объект ThreadPoolExecutor, вызывается метод getAdvice у AdviceHelper, который возвращает более эффективный аналог. Но чтобы сформировать наиболее полный список аналогов, метод getAdvice вызывается ещё раз для результата предыдущего вызова. Так происходит до тех пор, пока программа не достигнет самого оптимального виджета. Все виджеты будут описаны в результате, который уже на главном потоке передаётся в переданный методу callback. В иерархии реального приложения некоторые названия виджетов могут отличаться от того, что есть в базе данных. Например, вместо TextView можно встретить AppCompatTextView. Такая замена совершается операционной системой и предусматривается алгоритмами поиска в базе данных.
	
	Класс AdviceHelper наследует SQLiteOpenHelper и инкапсулирует всю работу с базой данных. Одна из главных задач, которую он решает, это использование заранее готовой базы данных. Изначально база данных находится в специальном месте для бинарных файлов, но использовать её из этой директории нельзя, так как SQLiteOpenHelper работает только с базами, созданными самим приложением, и находящимися в специальной директории. Чтобы решить эту задачу, при инстанциировании AdviceHelper проверяет, существует ли база данных, созданная приложением. Если такой нет, значит запуск библиотеки с этим приложением происходит впервые. В этом случае файл базы копируется из изначальной директории в директорию с базами данных приложения. Если база уже существует, открывается соединение к ней для проверки её версии. Если версия совпадает с ожидаемой, база закрывается, если нет, база возможно устарела. В случае устаревшей базы данных, она удаляется и заново копируется из директории с оригинальным файлом, который мог измениться.
	
	В методе init класса UIManager я создаю конкретные реализации Adviser и RecommendationOutputter, передавая их в конструктор конкретного HierarchyAnalyzer. Затем вызываю на объекте приложения registerActivityLifecycleCallbacks, а в реализации Application.ActivityLifecycleCallbacks при приобретении какой-либо Activity состояния Started, с помощью метода getActivityRoot я получаю корень его иерархии и передаю его в метод analyzeDynamicHierarchy созданного ранее HierarchyAnalyzer.
	
	\newpage
	\section{Демонстрация работы / Методики и результаты экспериментального исследования макета и/или опытного образца и/или программного продукта}
	
	\textbf{\Huge TODO}
	
	\newpage
	\centertitletoc{Заключение}
	
	\textbf{\Huge TODO}
	
	\newpage
	\centertitletoc{Дальнейшие исследования}
	
	Можно добавить клики, можно добавить перерисовку виджета, вызовом метода invalidate.
	
	\textbf{\Huge TODO}
	
	\newpage
	\centertitletoc{Краткий глоссарий, представляющий определение ключевых понятий и терминов работы}
	
	\textbf{\Huge TODO}

	\newpage
	\centertitletoc{Перечень сокращений, условных обозначений, символов и терминов}
	
	\textbf{\Huge TODO}
	
	\newpage
	\centertitletoc{Список использованных источников}
	
	\printbibliography[heading=none]
	
	\newpage
	\centertitletoc{Приложения}
	
	\textbf{\Huge TODO}
\end{document}
