% !TEX TS-program = xelatex
% !TEX encoding = UTF-8 Unicode
% !TEX spellcheck = ru-RU
% !BIB program = biber

\documentclass[a4paper,14pt]{extarticle} % ext for 14 font

\usepackage{etoolbox}
\newbool{comicsans}
\boolfalse{comicsans}

\input{preamble}

\begin{document}
	\include{title_page}
	\centertitle{Задание на ВКР}
	\section{График выполнения ВКР}
	\centertitle{Аннотация на русском языке}
	\centertitle{Аннотация на английском языке}
	
	\newpage
	\tableofcontents
	
	\input{intro}
	
	\newpage
	\section{Актуальность работы}
	
	Смартфон — неотъемлемая часть жизни современного человека. Человек может использовать телефон до 200 раз каждый день [1]. Тем не менее, смартфоны всё ещё не достигли потолка своего развития и многие аспекты нуждаются в улучшении. Одним из таких является энергопотребление устройства.
	
	Проблема заключается в том, что с развитием вычислителей и экранов, которые потребляют всё больше энергии, аккумуляторы должны развиваться с сопоставимой скоростью, чтобы покрыть растущие затраты и оставить время работы устройства от батареи хотя бы на том же уровне. Но развитие аккумуляторов устройств происходит не так быстро [2], что заставляет задуматься о более эффективном расходовании уже имеющейся энергии.
	
	Раньше мобильные телефоны могли работать более недели от одного заряда аккумулятора, но с их развитием такая возможность была потеряна. Как видно на диаграмме (рис. 1), процесс увеличения числа возможностей портативных устройств сопряжён с уменьшением времени работы прибора. Если в 1996 году портативное устройство было способно работать 8-10 недель до разрядки аккумулятора, то уже в 2004 году наличие камеры, диктофона, Bluetooth, цветного дисплея и другой функциональности сократили время работы до недели и меньше [3].
	
	Имеют место большое количество факторов, которые влияют на потребление энергии. Это взаимодействие с сетью, множество сенсоров и датчиков, камера, экран и другие. Существуют академические работы, показывающие возможность оптимизировать потребление многих факторов, например, взаимодействие с интернетом [4] или более оптимальное использование оперативной памяти может продлить срок работы устройства от аккумулятора [5]. Но также исследования показывают, что в большинстве сценариев использования смартфона энергозатраты на экран составляют больше половины всех энергозатрат [6]. Становится очевидным, что именно потребление экрана нуждается в оптимизации в первую очередь.
	
	Существует множество подходов к уменьшению потребления экрана, которые основываются на самых разных идеях. Некоторые считают, что изменение цветовой схемы интерфейса на AMOLED экранах поможет снизить затраты [7], другие понижают кадровую частоту и частоту обновления экрана [8, 9]. 
	
	Новизна моего исследования базируется на предположении, что взаимозаменяемые виджеты со схожей функциональностью потребляют разное количество энергии, что позволяет заменить более затратные виджеты на аналогичные и уменьшить энергопотребление.
	
	Практическое применение моей работы заключается в помощи разработчикам Android-приложений в выборе наиболее эффективных элементов графического интерфейса и улучшение общего качества приложения. Ожидается, что этого удастся достигнуть путём непрерывного сканирования иерархии виджетов с целью поиска тех, которые могут быть заменены на более оптимальные, и сообщения об этом разработчику мобильного приложения.
	
	\newpage
	\section{Анализ существующих технических решений объекта разработки}
	
	В этой главе я рассмотрю работы, рассматривающие пути оптимизации энергопотребления приложения. Это необходимо для понимания проделанной  исследователями работы, а также изучения методик и инструментов, используемых для проведения измерений.
	
	
	Почему эти направления
	
	Что я нашёл
	
	Методология
	
	Способы померить
	
	\textbf{\Huge TODO}
	
	\newpage
	\section{Инструменты для измерения энергопотребления}
	
	Измерение энергопотребления приложения в конкретный момент или небольшой промежуток времени — одна из самых важных и сложных задач, с которой мне пришлось  столкнуться в ходе выполнения ВКР.
	
	Необходимость в проведении таких измерений связана с необходимостью формирования базы данных элементов пользовательского интерфейса. В ходе работы системы контроля и управления энергопотребления  сформированная база элементов пользовательского интерфейса будет использоваться для сравнения данных по энергопотреблению текущих элементов с подобными по выполняемой функциональности и поиска наиболее энергоэффективных альтернатив.
	
	\subsection{Оптимизация измерений}
	
	Сложность проведения измерений энергопотребления приложения заключается в наличии большого количество факторов, влияющих на показатели энергопотребления, которые не связаны непосредственно с работой приложения. Такими факторами могут быть другие приложения, выполняющие работу в фоновом режиме, задачи операционной системы, а также особенности конкретного устройства. Избавиться от влияния всех факторов не представляется возможным, однако для уменьшения их влияния можно принять следующие меры:
	\begin{itemize}
		\item проводить тестирование на устройстве без сторонних приложений;
		\item проводить тестирование на устройстве с операционной системой без сервисов Google Play Services, которые выполняют фоновые задачи операционной системы;
		\item проводить тестирование всех элементов интерфейса на одном и том же устройстве.
	\end{itemize}
	
	\subsection{Способы измерения}
	
	Для получения энергопотребления конкретного приложения могут быть использованы следующие подходы:
	\begin{itemize}
		\item получение данных по энергопотреблению приложения с помощью Android Profiler;
		\item анализ данных, хранящихся на устройстве, с помощью Battery Historian;
		\item измерение энергопотребления всего устройства с помощью стороннего оборудования;
		\item измерение энергопотребления всего устройства с помощью средств операционной системы.
	\end{itemize}
	
	Первые два подхода получения энергопотребления позволяют фильтровать потребление по отдельному приложению, но они показывают лишь примерные оценки. Android Profiler, к тому же, не учитывает потребляемую экраном мощность. Подход измерения потребления всего устройства с помощью средств операционной системы страдает от несовершенности API и выдаёт значение напряжения на батарее лишь около 100 раз за полный разряд устройства.
	
	\subsection{Обоснование выбранного инструмента}
	
	Самым надёжным способом в настоящий момент остаётся измерение потребления всего устройства с помощью стороннего оборудования. Данный подход используется практически всеми современными исследованиями, требующими измерения энергопотребления приложения. Устройство для измерения подключается к тестируемому устройству вместо аккумуляторной батареи и записывает показатели мощности устройства с некоторым интервалом. Устройства для измерения варьируются от платы Arduino с небольшой программой до оборудования, специально созданного для таких целей. Самым популярным решением является использование Monsoon Power Monitor, именно его я собирался использовать при проведении собственных измерений. 
	
	К сожалению, ввиду эпидемиологической обстановки, доставка устройства или его аналогов не представляется возможным, в связи с чем, при измерениях будут использованы данные операционной системы, которые позже будут проанализированы с помощью Battery Historian.
	
	\newpage
	\section{Проведение измерений}
	
	Ручное проведение измерений потребует огромное количество времени для переключения экранов с различными элементами интерфейса, а также данное переключение может исказить результаты. Поэтому необходимо разработать средства, позволяющие автоматизировать процесс измерения потребления.
	
	\subsection{Составление списка элементов для тестирования}
	
	Для того, чтобы проводить тестирование элементов интерфейса, нужно найти и перечислить все элементы интерфейса, которые могут работать без взаимодействия с другими элементами, следовательно, могут быть протестированы поодиночке. Для составления списка элементов был взят список всех сущностей в пакете android.widget в Android SDK Platform (29 API). После этого были вычеркнуты следующие сущности:
	\begin{itemize}
		\item deprecated классы, так как они не рекомендуются к использованию и в будущих версиях могут быть исключены;
		\item интерфейсы и адаптеры, так как они не являются виджетами;
		\item абстрактные классы, так как они не могут быть инстанциированы;
		\item вспомогательные классы, так как они не являются виджетами;
		\item виджеты, требующие наличие адаптера или презентера для отображения;
		\item наследники представлений, задачей которых является позиционирование других представлений, добавленных к текущему.
	\end{itemize}
	
	После этого остался список самостоятельных элементов, для которых необходимо написать программу тестирования.
	
	\subsection{Автоматические тесты}
	
	Автоматические тесты графического интерфейса помогут менять содержимое экрана через определённые промежутки времени. Это избавит меня от необходимости ручного управления переключением элементов и искажений, которые накладывает ручное переключение.
	
	\subsubsection{Проектирование тестов}
	
	Чтобы снизить влияние лишних элементов интерфейса, а также дополнительных сущностей Activity во время тестирования, программа будет в одном и том же Activity по порядку менять различные элементы интерфейса раз в минуту.
	
	Некоторые элементы, например TextView или ImageView, требуют наполнения каким-нибудь содержимым, чтобы отображаться на экране. Некоторые элементы требуют менее тривиальных манипуляций перед отображением. Чтобы унифицировать процесс обработки элемента перед и после добавления на экран, было принято решение создать ViewWrapper, который будет содержать класс требуемого представления, а также методы beforeAdd и afterAdd, которые будут вызваны до добавления на экран и после добавления на экран соответственно. 
	
	Если элементу требуются дополнительные действия, как в примерах выше, методы могут быть переопределены в наследниках класса ViewWrapper. При выполнении тестов, создаётся массив из объектов ViewWrapper, представляющих все тестируемые элементы. В цикле для каждого объекта массива производятся следующий действия:
	\begin{enumerate}
		\item Создаётся объект класса представления, содержащегося в объекте ViewWrapper.
		\item Activity очищается от всех отображаемых элементов.
		\item Вызывается метод beforeAdd для созданного объекта.
		\item Объект представления добавляется в Activity для отображения.
		\item Вызывается метод afterAdd для добавленного объекта.
		\item Приостановка выполнения на одну минуту.
	\end{enumerate}
	
	\subsection{Язык программирования и  инструментальные средства}
	
	Для того, чтобы упростить и унифицировать процесс измерения, необходимо написать программу, управляющую поведением устройства во время проведения измерений. В моей работе для этих целей было решено применить инструментарий автоматизированного тестирования программного обеспечения, который позволяет иметь полный контроль над всем происходящим в приложении. Рассмотрим инструменты, позволяющие писать тесты пользовательского интерфейса Android:
	\begin{itemize}
		\item appium;
		\item espresso;
		\item kakao;
		\item kaspresso.
	\end{itemize}
	
	Appium я счёл неподходящим, так как он не всегда стабильно работает, а также не поддерживает старые версии Android. У Espresso подобные проблемы отсутствуют, но присутствует проблема с избыточностью синтаксиса и нечитаемости итогового кода. Kakao и Kaspresso в свою очередь основываются на Espresso, но каждый по-своему исправляет избыточность синтаксиса с помощью возможностей языка Kotlin, но Kaspresso имеет расширенную функциональность, поэтому выбор пал на данный фреймворк.
	
	\newpage
	\section{Подключаемая библиотека}
	
	\textbf{\Huge TODO}
	
	\subsection{Проектирование библиотеки}
	
	Перед написанием кода подключаемой библиотеки, необходимо её спроектировать. Проектирование поможет сделать работу библиотеки более стабильной и готовой к различным изменениям. К тому же, на хорошо спроектированные модули гораздо легче написать тесты при необходимости. 
	
	Задача проектирования заключается в продумывании архитектуры программного продукта, то есть описания того, из каких частей он будет состоять и как они будут между собой связаны. В моём случае библиотека выполняет следующие действия:
	\begin{itemize}
		\item прослушивание событий открытия нового экрана;
		\item прослушивание событий добавления новых элементов на текущий экран;
		\item сравнение заданного элемента интерфейса с его альтернативами на основании базы данных;
		\item вывод результата.
	\end{itemize}
	Изначально кажется, что первые две задачи очень похожи, но на деле это не совсем так, потому что за это отвечают разные механизмы и новый экран может быть открыт несколькими разными способами. Поэтому было решено разделить библиотеку на следующие модули:
	\begin{itemize}
		\item UIManager – точка входа в программу, которой необходим объект класса Application для установления слушателей открытия нового экрана. Здесь же определяются, какие реализации остальных компонентов будут использованы в работе.
		\item HierarchyAnalyzer – абстракция с методом analyzeDynamicHierarchy и полями типа Adviser и RecommendationOutputter. Этот класс будет слушать изменения в существующих иерархиях элементов, обращаясь к Adviser, чтобы сравнить элемент с имеющимися в базе данных и к RecommendationOutputter, чтобы вывести полученный результат.
		\item Adviser абстракция с методом findAlternative, который ищет оптимальный элемент, подобный заданному.
		\item RecommendationOutputter абстракция с методом output, принимающим оригинальный элемент интерфейса и строку с описанием альтернативы.
	\end{itemize}
	
	Позднее может быть добавлена дополнительная абстракция для работы с базой  данных, она будет связана только с Adviser.
	
	\subsection{Язык программирования и  инструментальные средства}
	
	Теперь нужно определиться, какими инструментами предстоит пользоваться при написании кода библиотеки. Самое основное — язык написания. Для разработки встраиваемой библиотеки необходимо использовать язык программирования Java и/или Kotlin. Дополнительно могут быть использованы модули, скомпилированные в .so файл, и написанные на любом языке, поддерживающие такую компиляцию. 
	
	Нет необходимости пользоваться возможностью подключения .so файлов в данном проекте, так как задачи обеспечения повышенной производительности или потребности в более тонком управлении памятью здесь не стоит. Языки Kotlin и Java не имеют разницы в производительности, так как в итоге компилируются в одинаковый байт-код. Вопрос только в удобстве написания, и здесь в большинстве случаев выигрывает Kotlin, позволяющий писать код более короткий и более читаемый для человека код. Так как эти языки совместимы, при необходимости можно будет написать фрагмент программы на языке Java, но основным языком разработки я выбрал Kotlin.
	
	Так как языки Java и Kotlin совместимы, я могу для написания собственной библиотеки использовать другие библиотеки, написанные как на языке Java, так и на языке Kotlin. Сторонние библиотеки могут упростить прослушивание событий, работу с базой данных, реализацию алгоритмов сравнения элементов друг с другом и так далее. Но чтобы не увеличивать размер библиотеки и не добавлять в неё функциональность из сторонней библиотеки, которая не будет использована, я решил пользоваться только средствами Android SDK, а также языков Java и Kotlin.
	
	В библиотеке мне предстоит отслеживать смену экранов и динамическое изменение иерархий элементов, в Android SDK для этого имеются такие средства как Application.ActivityLifecycleCallbacks, FragmentManager.FragmentLifecycleCallbacks и ViewGroup.OnHierarchyChangeListener. ActivityLifecycleCallbacks используются для отслеживания изменений состояния жизненного цикла Activity, его удобно использовать, чтобы определять, что создалась новая сущность Activity (для этой сущности будет вызван метод жизненного цикла onCreate). FragmentLifecycleCallbacks может использоваться для отслеживания жизненного цикла Fragment (компонент, который может представлять собой отдельный экран или его часть). OnHierarchyChangeListener в свою очередь позволяет отслеживать динамические изменения иерархии элементов графического интерфейса.
	
	Так как ViewGroup.OnHierarchyChangeListener полностью покрывает все текущие сценарии использования FragmentManager.FragmentLifecycleCallbacks, было решено сипользовать Application.ActivityLifecycleCallbacks для определения появления новых Activity вместе с ViewGroup.OnHierarchyChangeListener, чтобы находить новые сущности Fragment и вручную добавляемые программистом представления.

	\subsection{Разработка}
	
	При написании кода я решил начать с описания спроектированной архитектуры в синтаксисе языка программирования Kotlin. UIManager – singleton-объект, содержащий методы init и getActivityRoot. Первый —  точка входа в приложение, он принимает объект приложения и ничего не возвращает. getActivityRoot принимает на вход объект Activity и возвращает корневое представление иерархии, привязанное к этому Activity. Adviser – интерфейс с методом findAlternative, который принимает имя класса представления, которое необходимо проанализировать, и возвращает строку с рекомендацией, либо null. RecommendationOutputter тоже интерфейс с методом output, принимающим объект View, для которого сформирована рекомендация и сама рекомендация в виде строки. HierarchyAnalyzer —  абстрактный класс, так как у него имеется конструктор, принимающий реализации Adviser и RecommendationOutputter и сохраняющий их в поля на уровне абстрактного класса. Также он HierarchyAnalyzer содержит абстрактный метод analyzeDynamicHierarchy, который принимает корень иерархии элементов, которую необходимо проанализировать.
	
	Реализация HierarchyAnalyzer содержит объект OnHierarchyChangeListener, который она передаёт всем объектам ViewGroup, встречающимся в иерархии. Для прохода иерархии используется итерирование по всем дочерним элементам корневого элемента и рекурсивного вызова analyzeDynamicHierarchy в случае, если один из дочерних элементов теоретически может содержать дочерние элементы. Реализация OnHierarchyChangeListener вызывает метод analyzeDynamicHierarchy для каждого динамически добавленного элемента.
	
	В качестве реализации интерфейса RecommendationOutputter используется LogOutputter, выводящий информацию в логи устройства. При вызове метода output реализация проходит по всем родительским элементам, чтобы составить полный адрес текущего элемента в иерархии. Для смены порядка родительских элементов (идём снизу вверх по иерархии, выводим её сверху вниз) используется стек. После этого формируется сообщение, содержащее класс объекта, его расположение в иерархии и совет по оптимизации. Сообщение выводится в логи устройства.
	
	На данный момент база данных элементов и их энергозатрат ещё не сформирована, поэтому используется RandomAdviser, который для каждого виджета даёт случайный совет. Благодаря продуманной архитектуре, не составит труда в будущем заменить этот класс на полезную реализацию Adviser.
	
	В методе init класса UIManager я создаю конкретные реализации Adviser и RecommendationOutputter, передавая их в конструктор конкретного HierarchyAnalyzer. Затем вызываю на объекте приложения registerActivityLifecycleCallbacks, а в реализации Application.ActivityLifecycleCallbacks при приобретении какой-либо Activity состояния Started, с помощью метода getActivityRoot я получаю корень его иерархии и передаю его в метод analyzeDynamicHierarchy созданного ранее HierarchyAnalyzer.
	
	
	\newpage
	\section{Результаты измерений}
	
	
	\newpage
	\section{Демонстрация работы / Методики и результаты экспериментального исследования макета и/или опытного образца и/или программного продукта}
	
	\textbf{\Huge TODO}
	
	\newpage
	\centertitletoc{Заключение}
	
	\newpage
	\section{Краткий глоссарий, представляющий определение ключевых понятий и терминов работы}

	\newpage
	\section{Перечень сокращений, условных обозначений, символов и терминов}
	
	\newpage
	\section{Список использованных источников}
	
	\newpage
	\section{Приложения}
\end{document}
